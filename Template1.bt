//------------------------------------------------
//--- 010 Editor v14.0.1 Binary Template
//--- Bitlocker Metadata Analyser
//------------------------------------------------

// Basics.h from https://github.com/DeKaDeNcE/wow010/blob/master/basics.h : (relaxok, 2018)
// To include the definition for int24_t
#include <basics.h>

typedef enum <uint32> {
    FILE_SYSTEM_TYPE_NONE    = 0x0000,
    FILE_SYSTEM_TYPE_IFS     = 0x0010,
    FILE_SYSTEM_TYPE_NTFS    = 0x0020,
    FILE_SYSTEM_TYPE_HPFS    = 0x0040,
    FILE_SYSTEM_TYPE_FAT12   = 0x0100,
    FILE_SYSTEM_TYPE_FAT16   = 0x0200,
    FILE_SYSTEM_TYPE_FAT32   = 0x0400,
    FILE_SYSTEM_TYPE_EXFAT   = 0x0800,
} FILE_SYSTEM_TYPE <read=ReadFILE_SYSTEM_TYPE>;
// Media descriptor
typedef enum <uchar>
{
    FLOPPY                        = 0xf0,
    HARD_DRIVE                    = 0xf8,
    FLOPPY_320K_1                 = 0xfa,
    FLOPPY_640K                   = 0xfb,
    FLOPPY_180K                   = 0xfc,
    FLOPPY_360K                   = 0xfd,
    FLOPPY_160K                   = 0xfe,
    FLOPPY_320K_2                 = 0xff,
} MEDIA <format=hex>;

typedef struct  {
    local INT64 tmp <hidden=true>;
    local DWORD ClusterSize;
    local DWORD NumberOfSectors;
    local DWORD SectorsPerFat;
    local DWORD CountOfDataClusters;
    local DWORD MaximumValidClusterNumber;

    local FILE_SYSTEM_TYPE FsType = FILE_SYSTEM_TYPE_NONE;

    BYTE    jmp[3]                <format=hex>;
    CHAR    OemName[8];
    USHORT  BytesPerSector        <format=hex>; // legal == { 512, 1024, 2048, 4096 }
    UBYTE   SectorsPerCluster     <format=hex>; // legal == { 1, 2, 4, 8, 16, 32, 64, 128 }
    USHORT  ReservedSectors       <format=hex>; // must not be zero; legal for FAT12/16 == { 1 }, typically 32 for FAT32
    UBYTE   NumberOfFatTables     <format=hex>; // must not be zero; warn if this is not set to the value 1 or 2
    USHORT  MaxRootDirEntries     <format=hex>; // legal for FAT12/16 == N * (BytesPerSector / 32), N is non-zero; must be {0} for FAT32
    USHORT  NumberOfSectors16     <format=hex>; // must be {0} for FAT32; if {0}, then NumberOfSectors32 must be non-zero
    MEDIA   MediaDescriptor       <format=hex>; // legacy
    USHORT  SectorsPerFat16       <format=hex>; // must be {0} for FAT32; must be non-zero for FAT12/16
    USHORT  SectorsPerTrack       <format=hex>; // legacy
    USHORT  HeadsPerCylinder      <format=hex>; // legacy
    ULONG   NumHiddenSectors      <format=hex>; // legacy
    ULONG   NumberOfSectors32     <format=hex>; // must be non-zero for FAT32; must be >= 0x10000 if NumberOfSectors16 is zero

    // PREVENTS ARRAY OPTIMIZATION because depends on instance value
    if (0 == this.SectorsPerFat16) { // FAT32 starting at sector offset 36 
        DWORD SectorsPerFat32    <format=hex>;
        WORD  ActiveFatIndex : 4 <format=hex>; // zero-based index of the active FAT
        WORD  FlagsReserved1 : 3 <format=hex>; 
        WORD  TransactionFat : 1 <format=hex>; // 1 means only one FAT active, as indicated by ActiveFatIndex; 0 means both FATs are mirrored
        WORD  FlagsReserved2 : 8 <format=hex>;
        WORD  Version            <format=hex>; // must be 0
        DWORD RootCluster        <format=hex>; // cluster number (FAT index) for root.  usually 2.  preferably first non-bad sector.
        WORD  InfoSector         <format=hex>; // usually 1.
        WORD  BootBackupStart    <format=hex>; // usually 6.  No other value than 6 is recommended
        BYTE  Reserved[12]       <format=hex>; // set to zero by formatting utility, no indicaton of other uses but shall be ignored/preserved
    }

    BYTE   DriveNumber        <format=hex>;
    BYTE   Unused             <format=hex>;
    BYTE   ExtBootSignature   <format=hex>;
    DWORD  SerialNumber       <format=hex>; // only valid if ExtBootSignature == 0x29
    CHAR   VolumeLabel[11]    <format=hex>; // only valid if ExtBootSignature == 0x29
    CHAR   FileSystemLabel[8] <format=hex>; // only valid if ExtBootSignature == 0x29

    // PREVENTS ARRAY OPTIMIZATION
    // Added Bitlocker Specific Metadata
    tmp = 510 - (FTell() - startof(jmp)) - 110; // 420 for FAT32, 448 for FAT16/12
    UBYTE  BootCode1[70]       <format=hex>;
    GUID   BitlockerID;
    uint64  FVEMetatdata1      <format=hex>;
    uint64  FVEMetatdata2      <format=hex>;
    uint64  FVEMetatdata3      <format=hex>;
    UBYTE  BootCode[tmp-3]      <format=hex>;
    UBYTE   stringOffsets[3]   <format=hex>;
    WORD   EndOfSectorMarker  <format=hex>;

    // Helpers to make FAT12/16/32 more common -- all of which prevent array optimization
    ClusterSize      = this.BytesPerSector * this.SectorsPerCluster;
    NumberOfSectors  = (this.NumberOfSectors16 != 0) ? this.NumberOfSectors16 : this.NumberOfSectors32;
    SectorsPerFat    = (this.SectorsPerFat16   != 0) ? this.SectorsPerFat16   : this.SectorsPerFat32;
    CountOfDataClusters = ReadFAT_BOOTSECTOR_CountOfDataClusters(this);
    MaximumValidClusterNumber = CountOfDataClusters + 1; // +2, but zero-based indexing, so largest valid value is Count+1

    if (CountOfDataClusters == 0) {
        //Printf("WARNING: Count of data clusters computed as zero, so not valid FAT filesystem\r\n");
        FsType = FILE_SYSTEM_TYPE_NONE; // oops
    } else if (CountOfDataClusters < 4085) {
        FsType = FILE_SYSTEM_TYPE_FAT12;
    } else if (CountOfDataClusters < 65525) {
        FsType = FILE_SYSTEM_TYPE_FAT16;
    } else if (CountOfDataClusters < 0x0FFFFFF0 - 2) {
        FsType = FILE_SYSTEM_TYPE_FAT32;
    } else {
        FsType = FILE_SYSTEM_TYPE_NONE; // oops
    }
    //https://github.com/thewhiteninja/ntfstool/blob/master/Sources/Commands/command_vbr.cpp#L292
    FSeek(header.stringOffsets[0]+0x100);
local string stringStore;
stringStore = ReadString(FTell(),0x30);
local int strLen = Strstr(stringStore,'\xFF');
char string1[strLen]; 
FSeek(header.stringOffsets[1]+0x100);
stringStore = ReadString(FTell(),0x30);
strLen = Strstr(stringStore,'\xFF');
char string2[strLen]; 
FSeek(header.stringOffsets[2]+0x100);
string string3;
} FAT_BOOTSECTOR <read=ReadFAT_BOOTSECTOR, optimize=false>;
string ReadFAT_BOOTSECTOR( FAT_BOOTSECTOR &boot )
{
    return boot.VolumeLabel;
}
typedef enum <int> {
    boolean_false = 0,
    boolean_true = 1,
    boolean_true_negative_one = -1,
    boolean_just_use_true_and_false = 0xbaadf00d
} boolean;

boolean IsExactlyOneBitSet( UQUAD value ) {  return 0 == (value & (value-1));}


DWORD ReadFAT_BOOTSECTOR_CountOfDataClusters( FAT_BOOTSECTOR &boot )
{
    local DWORD rootDirectoryByteCount <hidden=true>;
    local DWORD rootDirectorySectors <hidden=true>;
    local DWORD sectorsPerFat <hidden=true>;
    local DWORD totalSectors <hidden=true>;
    local DWORD dataSectors <hidden=true>;
    local DWORD countOfClusters <hidden=true>;

    if (boot.BytesPerSector == 0) return 0;
    if (!IsExactlyOneBitSet(boot.BytesPerSector)) return false;

    if (boot.BytesPerSector != 512) { // TODO: Fix 4k native sectors to show correct file data
        Printf("WARNING: Potentially valid FAT file system at 0x%x.\r\n", startof(boot));
        Printf("         Shows non-512 bytes per sector (0x%x)\r\n", boot.BytesPerSector);
        Printf("         Treating as unsupported drive due to known bugs\r\n");
        return 0; 
    }

    // First, the number of sectors in the special root directory area
    rootDirectoryByteCount = boot.MaxRootDirEntries * 32;
    rootDirectorySectors = rootDirectoryByteCount / boot.BytesPerSector;
    if (rootDirectoryByteCount % boot.BytesPerSector != 0) {
        rootDirectorySectors++;
    }

    // Next, the number of sectors in the data region
    sectorsPerFat    = boot.SectorsPerFat;
    totalSectors     = boot.NumberOfSectors;
    dataSectors      = totalSectors;
    dataSectors     -= boot.ReservedSectors;
    dataSectors     -= boot.NumberOfFatTables * sectorsPerFat;
    dataSectors     -= rootDirectorySectors;
    countOfClusters  = dataSectors / boot.SectorsPerCluster; // note that this rounds down
    return countOfClusters;
}

FAT_BOOTSECTOR header;


#include <TPM20.h>
struct bde_metadata_block_header_v1
{
	/* The signature
	 * Consists of 8 bytes
	 * Contains: -FVE-FS-
	 */
	char signature[ 8 ];

	/* The size
	 * Consists of 2 bytes
	 */
	short size;

	/* The version
	 * Consists of 2 bytes
	 */
	short version;

	/* Unknown
	 * Consists of 2 bytes
	 */
	short unknown1 <format=hex>;

	/* Unknown
	 * Consists of 2 bytes
	 */
	short unknown2 <format=hex>;

	/* Unknown
	 * Consists of 16 bytes
	 */
	byte unknown3[ 16 ] <format=hex>;

	/* The first FVE metadata offset
	 * Consists of 8 bytes
	 */
	int64 first_metadata_offset <format=hex>;

	/* The second FVE metadata offset
	 * Consists of 8 bytes
	 */
	int64 second_metadata_offset <format=hex>;

	/* The third FVE metadata offset
	 * Consists of 8 bytes
	 */
	int64 third_metadata_offset <format=hex>;

	/* The MFT mirror cluster block number
	 * Consists of 8 bytes
	 */
	int64 mft_mirror_cluster_block <format=hex>;
};

struct bde_metadata_block_header_v2
{
	/* The signature
	 * Consists of 8 bytes
	 * Contains: -FVE-FS-
	 */
	char signature[ 8 ];

	/* The size
	 * Consists of 2 bytes
	 */
	short size;

	/* The version
	 * Consists of 2 bytes
	 */
	short version;

	/* Unknown
	 * Consists of 2 bytes
	 */
	short unknown1 <format=hex>;

	/* Unknown
	 * Consists of 2 bytes
	 */
	short unknown2 <format=hex>;

	/* The encrypted volume size
	 * Consists of 8 bytes
	 */
	int64 encrypted_volume_size;

	/* Unknown
	 * Consists of 4 bytes
	 */
	int unknown3 <format=hex>;

	/* The number of volume header sectors
	 * Consists of 4 bytes
	 */
	int number_of_volume_header_sectors;

	/* The first FVE metadata offset
	 * Consists of 8 bytes
	 */
	int64 first_metadata_offset <format=hex>;

	/* The second FVE metadata offset
	 * Consists of 8 bytes
	 */
	int64 second_metadata_offset <format=hex>;

	/* The third FVE metadata offset
	 * Consists of 8 bytes
	 */
	int64 third_metadata_offset <format=hex>;

	/* The volume header offset offset
	 * Consists of 8 bytes
	 */
	int64 volume_header_offset <format=hex>;
};

struct bde_metadata_header_v1
{
	/* The metadata size
	 * Consists of 4 bytes
	 */
	int metadata_size;

	/* The version
	 * Consists of 4 bytes
	 */
	int version;

	/* The metadata header size
	 * Consists of 4 bytes
	 */
	int metadata_header_size;

	/* The metadata size copy
	 * Consists of 4 bytes
	 */
	int metadata_size_copy;

	/* The volume identifier
	 * Consists of 16 bytes
	 */
	GUID volume_identifier;

	/* The next nonce counter
	 * Consists of 4 bytes
	 */
	int next_nonce_counter;

	/* The encryption method
	 * Consists of 2 bytes
	 */
	ushort encryption_method <format=hex>;

	/* The encryption method copy
	 * Consists of 2 bytes
	 */
	ushort encryption_method_copy <format=hex>;

	/* The creation date and time
	 * Consists of 8 bytes
	 * Contains a filetime
	 */
	FILETIME creation_time;
};

/*
enum<ushort> ENC_TYPES{
NOT_ENC_OR_Ext = 0x0000,

STRETCH_0 = 0x1000,
STRETCH_1 = 0x1001,

AES_CCM_256_0 = 0x2000,
AES_CCM_256_1 = 0x2001,
AES_CCM_256_2 = 0x2002,
AES_CCM_256_3 = 0x2003,
AES_CCM_256_4 = 0x2004,
AES_CCM_256_5 = 0x2005,

AES_CBC_128_ED = 0x8000,
AES_CBC_256_ED = 0x8001,
AES_CBC_128 = 0x8003,
AES_CBC_256 = 0x8003,
AES_XTS_128 = 0x8004,
AES_XTS_256 = 0x8005
};
*/
enum<WORD> DATUM_TYPES{
FveDatumErasedTypeProp = 0,
FveDatumKeyTypeProp,
FveDatumUnicodeTypeProp,
FveDatumStretchKeyTypeProp,
FveDatumUseKeyTypeProp,
FveDatumAesCcmEncTypeProp,
FveDatumTpmEncBlobTypeProp,
FveDatumValidationInfoTypeProp,
FveDatumVmkInfoTypeProp,  
FveDatumExternalInfoTypeProp,    
FveDatumUpdateTypeProp, 
FveDatumErrorTypeProp,   
FveDatumAsymEncTypeProp,
FveDatumExportedKeyTypeProp,
FveDatumPublicKeyInfoTypeProp,
FveDatumVirtualizationInfoTypeProp,
FveDatumSimpleTypeProp1,
FveDatumSimpleTypeProp2,
FveDatumConcatHashKeyTypeProp,
FveDatumSimpleTypeProp3,
FveDatumSimpleLargeTypeProp,
FveDatumBackupInfoTypeProp
};

enum<WORD> ROLE_TYPES{
PROP = 0x0000,
VMK = 0x2,
FVEK,
VALID,
EXT_KEY = 0x6,
DESCRIPTION,
/*https://github.com/thewhiteninja/ntfstool/blob/master/Sources/Bitlocker/fve.h#L28*/
FVEK_BAK = 0xb, /*Maybe AutoUnlock*/
VOL_HEAD = 0xf    
};

local int DatumSizes[22] = {
/*FveDatumErasedTypeProp, 0,*/              08h
/*FveDatumKeyTypeProp, 1*/,                 0Ch
/*FveDatumUnicodeTypeProp, 2*/,             08h
/*FveDatumStretchKeyTypeProp, 3*/,          1Ch
/*FveDatumUseKeyTypeProp, 4*/,              0Ch
/*FveDatumAesCcmEncTypeProp, 5*/,           24h
/*FveDatumTpmEncBlobTypeProp, 6*/,          0Ch
/*FveDatumValidationInfoTypeProp, 7*/,      08h
/*FveDatumVmkInfoTypeProp, 8*/,             24h    
/*FveDatumExternalInfoTypeProp, 9*/,        20h     
/*FveDatumUpdateTypeProp, 10*/,             2Ch    
/*FveDatumErrorTypeProp, 11*/,              34h    
/*FveDatumAsymEncTypeProp, 12*/,            08h
/*FveDatumExportedKeyTypeProp, 13*/,        08h
/*FveDatumPublicKeyInfoTypeProp, 14*/,      08h
/*FveDatumVirtualizationInfoTypeProp, 15*/, 18h
/*FveDatumSimpleTypeProp1, 16*/,            0Ch
/*FveDatumSimpleTypeProp2, 17*/,            0Ch
/*FveDatumConcatHashKeyTypeProp, 18*/,      1Ch
/*FveDatumSimpleTypeProp3, 19*/,            0Ch
/*FveDatumSimpleLargeTypeProp, 20*/,        10h
/*FveDatumBackupInfoTypeProp, 21*/,         1Ch
};

enum<ushort> cipher_types
{
    /** From FveVmkInfoConvertCreateParams and FveVmkInfoCreate and FveDatumPerformConcatHash**/
	STRETCH_KEY   = 0x1000,
	AES_CCM_256_0 = 0x2000,
	AES_CCM_256_1 = 0x2001,
	AES_CCM_256_EXTERN_KEY    = 0x2002,
	AES_CCM_256_VMK           = 0x2003,
	AES_CCM_256_PIN = 0x2004,
    /* From FveDatumPerformConcatHash */
	AES_CCM_256_CONCAT_HASH      = 0x2005,
	AES_CCM_256_PUBLIC_KEY      = 0x2006,
	AES_CCM_256_PASSPHRASE     = 0x2007,
    AES_CCM_256_REOCVERY_PASSWORD = 0x2008,
    /**                                                         **/
    
	AES_128_DIFFUSER    = 0x8000,
	AES_256_DIFFUSER    = 0x8001,
	AES_128_NO_DIFFUSER = 0x8002,
	AES_256_NO_DIFFUSER = 0x8003,
	AES_XTS_128         = 0x8004,
	AES_XTS_256         = 0x8005,

	DIS_CIPHER_LOWEST_SUPPORTED  = 0x8000,
	DIS_CIPHER_HIGHEST_SUPPORTED = 0x8005,
};

// Structures we want.
// BitLocker metadata header. (BitLocker Drive Encryption (BDE) format.asciidoc 5.2)
struct _FVE_DATASET
{
  unsigned int DataSetSize;
  unsigned int DataSetVersion;
  unsigned int DataSetStart;
  unsigned int DataSetEnd;
  GUID FveIdentification;
  unsigned int NonceCounter;
  cipher_types FvekType <format=hex>;
  cipher_types FvekPrefType <format=hex>;
  FILETIME DateTime;
};

// BitLocker metadata entry header. (BitLocker Drive Encryption (BDE) format.asciidoc 5.3)
struct  _FVE_DATUM
{
  WORD StructureSize;
  ROLE_TYPES Role;
  DATUM_TYPES Type;
  WORD Flags;
};

// BitLocker key metadata blob. (BitLocker Drive Encryption (BDE) format.asciidoc 5.4)
struct _FVE_DATUM_KEY
{
  _FVE_DATUM h;
  WORD KeyType;
  WORD KeyFlags; // bit 0 internally used as "derived from TPM, ensure secureboot policy flag bit2 is set", but not ever set elsewhere...
  byte KeyData[h.StructureSize-12];
};

struct _FVE_DATUM_VMK_INFO
{
  _FVE_DATUM h;
  GUID Identifier;
  FILETIME DateTime;
  WORD VmkHints;
  WORD ProtectionType;
};
// BitLocker key metadata blob. (BitLocker Drive Encryption (BDE) format.asciidoc 5.4)


struct bde_metadata_entry_v1
{
	/* The size
	 * Consists of 2 bytes
	 */
	int size[ 2 ];

	/* The type
	 * Consists of 2 bytes
	 */
	int type[ 2 ];

	/* The value type
	 * Consists of 2 bytes
	 */
	int value_type[ 2 ];

	/* The version
	 * Consists of 2 bytes
	 */
	int version[ 2 ];

};

struct bde_metadata_entry_key_header
{
	/* The encryption method
	 * Consists of 4 bytes
	 */
	cipher_types encryption_method <format = hex>;
};

struct bde_metadata_entry_stretch_key_header
{
	/* The encryption method
	 * Consists of 4 bytes
	 */
	cipher_types encryption_method[ 4 ];

	/* The salt
	 * Consists of 16 bytes
	 */
	int salt[ 16 ];
};

struct bde_metadata_entry_aes_ccm_encrypted_key_header
{
	/* The nonce date and time
	 * Consists of 8 bytes
	 * Contains a filetime
	 */
	FILETIME nonce_time;

	/* The nonce counter
	 * Consists of 4 bytes
	 */
	int nonce_counter;
};

struct bde_metadata_entry_volume_master_key_header
{
	/* The identfier
	 * Consists of 16 bytes
	 * Contains a GUID
	 */
	GUID identifier;

	/* The (last) modification date and time
	 * Consists of 8 bytes
	 * Contains a filetime
	 */
	FILETIME modification_time;

	/* Unknown
	 * Consists of 2 bytes
	 */
	short unknown1;

	/* The protection type
	 * Consists of 2 bytes
	 */
	int protection_type[ 2 ];
};

struct bde_metadata_entry_external_key_header
{
	/* The identfier
	 * Consists of 16 bytes
	 * Contains a GUID
	 */
	int identifier[ 16 ];

	/* The (last) modification date and time
	 * Consists of 8 bytes
	 * Contains a filetime
	 */
	int modification_time[ 8 ];
};

typedef struct _extended_info {
	uint16 unknown1;
	uint16 size;
	uint32 unknown2;
	uint64 flags;
	uint64 convertlog_addr;
	uint32 convertlog_size;
	uint32 sector_size1;
	uint32 sector_size2;
} extended_info_t;

struct PROTECTOR_TYPES{
byte    RESERVED;    
byte    TPM : 1;
byte    EXTERNAL_KEY : 1;
byte    PIN : 1  ;
byte    RECOVERY_PASSWORD   : 1;
byte    UKNOWN  :   1;
byte    PASSPHRASE  :   1;
};
/*
typedef struct _datum_aes_ccm
{
	datum_header_safe_t header;
	uint8_t nonce[12];
	uint8_t mac[16];
} datum_aes_ccm_t;
*/


string READ_PROTECTOR_TYPE(PROTECTOR_TYPES &flag){
    local string RetStr = "";
    if (flag.TPM){
        RetStr += "TPM";
    }
    if (flag.PIN){
        RetStr +=" + PIN";
        }
    if (flag.EXTERNAL_KEY){
        if (RetStr == ""){
            RetStr += "USB";
            }
        else{
            RetStr +=" + USB";
            }
        }
    if (flag.RECOVERY_PASSWORD){
        RetStr+="Recovery Password";
    }
    if (flag.PASSPHRASE){
        RetStr+="PassPhrase";
    }
    return RetStr;
};
/*
struct PROTECTOR_TYPES{
byte    RESERVED;    
byte    TPM : 1;
byte    EXTERNAL_KEY : 1;
byte    PIN : 1  ;
byte    RECOVERY_PASSWORD   : 1;
byte    UKNOWN  :   1;
byte    PASSPHRASE  :   1;
};
*/

/* Potential Key Flags suggested by
*  FveDatumVmkQueryIsEnhancedPinOrEnhancedCrypto and FveDatumFromPin
*/
enum<WORD> KEY_FLAGS{
    EnhancedPin  = 0x4,
    NonEnhancedPin = 0x10  
};
struct PCR_BITMAP;


string readPCR_BITMAP(PCR_BITMAP &pcrs){
    local string out = "PCRs: ";
    if (pcrs.PCR_0){
        out+="0, ";
        };
    if (pcrs.PCR_1){
        out+="1, ";
    }; 
    if (pcrs.PCR_2){
        out+="2, ";
    }; 
    if (pcrs.PCR_3){
        out+="3, ";
    };
    if (pcrs.PCR_4){
        out+="4, ";
    };
    if (pcrs.PCR_5){
        out+="5, ";
    }; 
    if (pcrs.PCR_6){
        out+="6, ";
    }; 
    if (pcrs.PCR_7){
        out+="7, ";
    }; 
    if (pcrs.PCR_8){
        out+="8, ";
    }; 
    if (pcrs.PCR_9){
        out+="9, ";
    }; 
    if (pcrs.PCR_10){
        out+="10, ";
    }; 
    if (pcrs.PCR_11){
        out+="11, ";
    }; 
    if (pcrs.PCR_12){
        out+="12, ";
    }; 
    if (pcrs.PCR_13){
        out+="13, ";
    }; 
    if (pcrs.PCR_14){
        out+="14, ";
    }; 
    if (pcrs.PCR_15){
        out+="15, ";
    }; 
    if (pcrs.PCR_16){
        out+="16, ";
    }; 
    if (pcrs.PCR_17){
        out+="17, ";
    };
    if (pcrs.PCR_18){
        out+="18, ";
    }; 
    if (pcrs.PCR_19){
        out+="19, ";
    }; 
    if (pcrs.PCR_20){
        out+="20, ";
    }; 
    if (pcrs.PCR_21){
        out+="21, ";
    }; 
    if (pcrs.PCR_22){
        out+="22, ";
    }; 
    if (pcrs.PCR_23){
        out+="23, ";
    }; 
    out = StrDel(out, Strlen(out)-2, 2);
    return out;
    };

    
typedef struct{
    short PCR_0 : 1;
    short PCR_1 : 1;
    short PCR_2 : 1;
    short PCR_3 : 1;
    short PCR_4 : 1;
    short PCR_5 : 1;
    short PCR_6 : 1;
    short PCR_7 : 1;
    short PCR_8 : 1;
    short PCR_9 : 1;
    short PCR_10 : 1;
    short PCR_11 : 1;
    short PCR_12 : 1;
    short PCR_13 : 1;
    short PCR_14 : 1;
    short PCR_15 : 1;
    byte PCR_16 : 1;
    byte PCR_17 : 1;
    byte PCR_18 : 1;
    byte PCR_19 : 1;
    byte PCR_20 : 1;
    byte PCR_21 : 1;
    byte PCR_22 : 1;
    byte PCR_23 : 1;
    }  PCR_BITMAP  <read = readPCR_BITMAP>;
    
    struct SENSITIVE_DUMMY (uint outPrivate_size) {
          /** Dummy TPM2B_SENSITIVE structure to work out size of encrypted data **/
      UINT16            sensitive_size;
      
      // TPMT_SENSITIVE    sensitiveArea:

      /* sensitiveType is the same as outPublic.publicArea.Type 
      *  TPM 2.0 Part 2 Page 158 (TCG, 2024b:158)
      */
      TPMI_ALG_PUBLIC             sensitiveType;
      
      // TPM2B_AUTH        authValue;
      UINT16    authValue_size;
      BYTE      authValue_buffer[32]; /*Guessed authValue size*/
      
      // TPM2B_DIGEST      seedValue;
      UINT16    seedValue_size;
      /* Size taken from outPublic.publicArea.nameAlg
      *  TPM 2.0 Part 1 Page 186 (TCG, 2024a:186)
      */
      BYTE      seedValue_buffer[32];

      // TPMU_SENSITIVE_COMPOSITE sensitive(sensitiveType):
      // TPM2B_SENSITIVE_DATA   bits:
      UINT16    bits_size;
      local long encSize = outPrivate_size
                                    -sizeof(integrityOuter)-sizeof(integrityInner)
                                        -sizeof(sensitive_size)-sizeof(sensitiveType)
                                            -sizeof(authValue_size)-sizeof(authValue_buffer)
                                                -sizeof(seedValue_size)-sizeof(seedValue_buffer)
                                                    -sizeof(bits_size);
      if (encSize == 44){
          LittleEndian();
          //_FVE_DATUM h;      // Example Values
           WORD StructureSize; // 0x002c /*Fixed*/
           ROLE_TYPES Role;    // 0x0000
           DATUM_TYPES Type;   // 0x0010 /*Most likely fixed*/
           WORD Flags;         // 0x0000
          
          cipher_types KeyType; /*AES_CCM_256_VMK*/
          KEY_FLAGS KeyFlags;   /*0x0000*/
          BYTE VMK[32];
          BigEndian();
      }else if (encSize == 80){
          LittleEndian();
          //_FVE_DATUM h;      // Example Values
           WORD StructureSize; // 0x002c /*Fixed*/
           ROLE_TYPES Role;    // 0x0000
           DATUM_TYPES Type;   // 0x0010 /*Most likely fixed*/
           WORD Flags;         // 0x0000
          FILETIME nonceTime;
          int nonceCounter;
          byte HMAC[16] <format=hex>;
          //AES-CCM Encrypted with SHA256{Stretched PIN + "BitlockerAuthData"}
           //_FVE_DATUM h;
            WORD StructureSize; // 0x002c /*Fixed*/
            ROLE_TYPES Role;
            DATUM_TYPES Type;   // 0x0010 /*Most likely fixed*/
            WORD Flags;
          
           cipher_types KeyType; 
           KEY_FLAGS KeyFlags;
           BYTE IK[32]; //Stored intermediate key not VMK
           BigEndian();
      }else{
      BYTE      EncryptedDatums[encSize];
      };
};
struct TPM2B_PRIVATE_W_DUMMY{
          
      // TPM2B_PRIVATE outPrivate:
      UINT16    outPrivate_size;
      
      // _PRIVATE buffer[size]:
      TPM2B_DIGEST      integrityOuter;
      TPM2B_DIGEST      integrityInner;
      // byte    encryptedSensitive[size-integrityOuter.size-integrityInner.size-4]:
      SENSITIVE_DUMMY    encryptedSensitive(outPrivate_size);
    };
struct _FVE_DATUM_TEMP;
struct _FVE_DATUM_TEMP
{
  _FVE_DATUM h;  
  
  if (h.Type == FveDatumErasedTypeProp){
    byte DatumData[h.StructureSize-8];
    }
  else if (h.Type == FveDatumKeyTypeProp){
    cipher_types KeyType;
    KEY_FLAGS KeyFlags; // bit 0 internally used as "derived from TPM, ensure secureboot policy flag bit2 is set", but not ever set elsewhere...
    byte KeyData[h.StructureSize-12];
    }
  else if (h.Type == FveDatumUnicodeTypeProp){
    wchar_t UnicodeData[(h.StructureSize-8)/2];
  }
  else if (h.Type == FveDatumStretchKeyTypeProp){
     /* The encryption method
	 * Consists of 4 bytes
	 */
	cipher_types encryption_method <format = hex>;
    
    /* Potentially represents keyFlags suggested by
    *  FveDatumVmkQueryIsEnhancedPinOrEnhancedCrypto and FveDatumFromPin
    */
    KEY_FLAGS  keyFlags; 
    
	/* The salt
	 * Consists of 16 bytes
	 */
	byte salt1[16] <format = hex>;
    
    local int Datums = GetNoOfDatums(h.StructureSize-28);
    _FVE_DATUM_TEMP StretchDatums[Datums] <read = READ_DATUM_TYPE,optimize=false>;
  }
  else if (h.Type == FveDatumUseKeyTypeProp){
      byte UseKeyData[4];
      byte DatumData[h.StructureSize-12];
  }
  else if (h.Type == FveDatumAesCcmEncTypeProp){
      FILETIME nonceTime;
      int nonceCounter;
      byte HMAC[16] <format=hex>;
      byte AesCCMData[h.StructureSize-36];  
  }
  else if (h.Type == FveDatumTpmEncBlobTypeProp){
      PCR_BITMAP PCRBitmap;
      byte zero; /*Potentially always 0x00*/
      BigEndian();
      
      // Can be uncommented but latter structure is used to determine encrypted data size
      // TPM2B_PRIVATE outPrivate; 
      TPM2B_PRIVATE_W_DUMMY outPrivateWDummy;

      TPM2B_PUBLIC outPublic;
      TPM2B_DIGEST PCRDigest;
      LittleEndian();
      byte sizeOfBitmap <format = hex>;
      PCR_BITMAP PCRBitmap_End;
  }
  else if (h.Type == FveDatumVmkInfoTypeProp){
        GUID Identifier;
        FILETIME DateTime;
        WORD VmkHints;
        PROTECTOR_TYPES ProtectionType<read=READ_PROTECTOR_TYPE>;
        local int Datums = GetNoOfDatums(h.StructureSize-36);
        _FVE_DATUM_TEMP VMKDatums[Datums] <read = READ_DATUM_TYPE,optimize=false>;
  }
  else if (h.Type == FveDatumVirtualizationInfoTypeProp){
        UINT64 NTFSBootSectorsAddr;
	    UINT64 BackupBytes;
        extended_info_t ExtendedInfo; 
        byte ExtExtInfo[h.StructureSize-sizeof(_FVE_DATUM)-sizeof(UINT64)-sizeof(UINT64)-sizeof(extended_info_t)];
  }
  else{
      byte KeyData[h.StructureSize-8];
  }
    
};
string READ_DATUM_TYPE(_FVE_DATUM_TEMP &datum){
    local string RetStr = "";
    RetStr += EnumToString(datum.h.Role);
    RetStr += ": ";
    RetStr += EnumToString(datum.h.Type);
    return RetStr;
};
int GetNoOfDatums(uint size){
    local uint currOffset = FTell();
    local uint sizeLeft = size;
    local int count = 0;
    local int sizeStore = 0;
    while (sizeLeft>0){
        sizeStore = ReadUShort(currOffset);
        currOffset += sizeStore;
        sizeLeft-=sizeStore;
        count+=1;
    }
    return count;
}

struct FveHeaderBlock(int currOffset){
    bde_metadata_block_header_v2 FVEBlockHeader;
    _FVE_DATASET FVEDataset;
    local int Datums = GetNoOfDatums(FVEDataset.DataSetSize - FVEDataset.DataSetStart);
    _FVE_DATUM_TEMP DATUMS[Datums] <read = READ_DATUM_TYPE, optimize=false>;
};

FSeek(header.FVEMetatdata1);
FveHeaderBlock FVEHeaderBlock1(header.FVEMetatdata1);

FSeek(header.FVEMetatdata2);
Printf("%x",header.FVEMetatdata2);
FveHeaderBlock FVEHeaderBlock2(header.FVEMetatdata2);

FSeek(header.FVEMetatdata3);
Printf("%x",header.FVEMetatdata3);
FveHeaderBlock FVEHeaderBlock3(header.FVEMetatdata3);

