//------------------------------------------------
//--- 010 Editor v14.0.1 Binary Template
//--- Bitlocker Metadata Analyser
//------------------------------------------------


//----------------------
//--- Basics.h from https://github.com/DeKaDeNcE/wow010/blob/master/basics.h : (relaxok, 2018)
// To include the definition for int24_t
#include <basics.h>
//---------------------//


//--------------------------------------
//--- Required definitions from Drive.bt (Vernoux and SweetScape Software, 2022)
typedef enum <uint32> {
    FILE_SYSTEM_TYPE_NONE    = 0x0000,
    FILE_SYSTEM_TYPE_IFS     = 0x0010,
    FILE_SYSTEM_TYPE_NTFS    = 0x0020,
    FILE_SYSTEM_TYPE_HPFS    = 0x0040,
    FILE_SYSTEM_TYPE_FAT12   = 0x0100,
    FILE_SYSTEM_TYPE_FAT16   = 0x0200,
    FILE_SYSTEM_TYPE_FAT32   = 0x0400,
    FILE_SYSTEM_TYPE_EXFAT   = 0x0800,
} FILE_SYSTEM_TYPE <read=ReadFILE_SYSTEM_TYPE>;
// Media descriptor
typedef enum <uchar>
{
    FLOPPY                        = 0xf0,
    HARD_DRIVE                    = 0xf8,
    FLOPPY_320K_1                 = 0xfa,
    FLOPPY_640K                   = 0xfb,
    FLOPPY_180K                   = 0xfc,
    FLOPPY_360K                   = 0xfd,
    FLOPPY_160K                   = 0xfe,
    FLOPPY_320K_2                 = 0xff,
} MEDIA <format=hex>;
//--------------------------------------//

//----------------------------------------
//--- Altered FAT_BOOTSECTOR from Drive.bt (Vernoux and SweetScape Software, 2022)
//--- Alterations denoted by: "//---"
typedef struct  {
    local INT64 tmp <hidden=true>;
    local DWORD ClusterSize;
    local DWORD NumberOfSectors;
    local DWORD SectorsPerFat;
    local DWORD CountOfDataClusters;
    local DWORD MaximumValidClusterNumber;

    local FILE_SYSTEM_TYPE FsType = FILE_SYSTEM_TYPE_NONE;

    BYTE    jmp[3]                <format=hex>;
    CHAR    OemName[8];
    USHORT  BytesPerSector        <format=hex>; // legal == { 512, 1024, 2048, 4096 }
    UBYTE   SectorsPerCluster     <format=hex>; // legal == { 1, 2, 4, 8, 16, 32, 64, 128 }
    USHORT  ReservedSectors       <format=hex>; // must not be zero; legal for FAT12/16 == { 1 }, typically 32 for FAT32
    UBYTE   NumberOfFatTables     <format=hex>; // must not be zero; warn if this is not set to the value 1 or 2
    USHORT  MaxRootDirEntries     <format=hex>; // legal for FAT12/16 == N * (BytesPerSector / 32), N is non-zero; must be {0} for FAT32
    USHORT  NumberOfSectors16     <format=hex>; // must be {0} for FAT32; if {0}, then NumberOfSectors32 must be non-zero
    MEDIA   MediaDescriptor       <format=hex>; // legacy
    USHORT  SectorsPerFat16       <format=hex>; // must be {0} for FAT32; must be non-zero for FAT12/16
    USHORT  SectorsPerTrack       <format=hex>; // legacy
    USHORT  HeadsPerCylinder      <format=hex>; // legacy
    ULONG   NumHiddenSectors      <format=hex>; // legacy
    ULONG   NumberOfSectors32     <format=hex>; // must be non-zero for FAT32; must be >= 0x10000 if NumberOfSectors16 is zero

    // PREVENTS ARRAY OPTIMIZATION because depends on instance value
    if (0 == this.SectorsPerFat16) { // FAT32 starting at sector offset 36 
        DWORD SectorsPerFat32    <format=hex>;
        WORD  ActiveFatIndex : 4 <format=hex>; // zero-based index of the active FAT
        WORD  FlagsReserved1 : 3 <format=hex>; 
        WORD  TransactionFat : 1 <format=hex>; // 1 means only one FAT active, as indicated by ActiveFatIndex; 0 means both FATs are mirrored
        WORD  FlagsReserved2 : 8 <format=hex>;
        WORD  Version            <format=hex>; // must be 0
        DWORD RootCluster        <format=hex>; // cluster number (FAT index) for root.  usually 2.  preferably first non-bad sector.
        WORD  InfoSector         <format=hex>; // usually 1.
        WORD  BootBackupStart    <format=hex>; // usually 6.  No other value than 6 is recommended
        BYTE  Reserved[12]       <format=hex>; // set to zero by formatting utility, no indicaton of other uses but shall be ignored/preserved
    }

    BYTE   DriveNumber        <format=hex>;
    BYTE   Unused             <format=hex>;
    BYTE   ExtBootSignature   <format=hex>;
    DWORD  SerialNumber       <format=hex>; // only valid if ExtBootSignature == 0x29
    CHAR   VolumeLabel[11]    <format=hex>; // only valid if ExtBootSignature == 0x29
    CHAR   FileSystemLabel[8] <format=hex>; // only valid if ExtBootSignature == 0x29

    // PREVENTS ARRAY OPTIMIZATION
    tmp = 510 - (FTell() - startof(jmp)) - 110; // 420 for FAT32, 448 for FAT16/12

    //--------------------------------------
    //--- Added Bitlocker Specific Metadata
    UBYTE  BootCode1[70]       <format=hex>;
    GUID   BitlockerID;
    uint64  FVEMetatdata1      <format=hex>;
    uint64  FVEMetatdata2      <format=hex>;
    uint64  FVEMetatdata3      <format=hex>;
    UBYTE  BootCode[tmp-3]      <format=hex>;
    //--- String offsets identified from:
    //--- https://github.com/thewhiteninja/ntfstool/blob/master/Sources/Commands/command_vbr.cpp#L292 (thewhiteninja, 2022)
    UBYTE   stringOffsets[3]   <format=hex>;
    WORD   EndOfSectorMarker  <format=hex>;
    //--------------------------------------//

    // Helpers to make FAT12/16/32 more common -- all of which prevent array optimization
    ClusterSize      = this.BytesPerSector * this.SectorsPerCluster;
    NumberOfSectors  = (this.NumberOfSectors16 != 0) ? this.NumberOfSectors16 : this.NumberOfSectors32;
    SectorsPerFat    = (this.SectorsPerFat16   != 0) ? this.SectorsPerFat16   : this.SectorsPerFat32;
    CountOfDataClusters = ReadFAT_BOOTSECTOR_CountOfDataClusters(this);
    MaximumValidClusterNumber = CountOfDataClusters + 1; // +2, but zero-based indexing, so largest valid value is Count+1

    if (CountOfDataClusters == 0) {
        //Printf("WARNING: Count of data clusters computed as zero, so not valid FAT filesystem\r\n");
        FsType = FILE_SYSTEM_TYPE_NONE; // oops
    } else if (CountOfDataClusters < 4085) {
        FsType = FILE_SYSTEM_TYPE_FAT12;
    } else if (CountOfDataClusters < 65525) {
        FsType = FILE_SYSTEM_TYPE_FAT16;
    } else if (CountOfDataClusters < 0x0FFFFFF0 - 2) {
        FsType = FILE_SYSTEM_TYPE_FAT32;
    } else {
        FsType = FILE_SYSTEM_TYPE_NONE; // oops
    }
    
    //--------------------------------------
    //--- String offsets calculations adapted from:
    //--- https://github.com/thewhiteninja/ntfstool/blob/master/Sources/Commands/command_vbr.cpp#L292 (thewhiteninja, 2022)
    FSeek(header.stringOffsets[0]+0x100);
    local string stringStore;
    stringStore = ReadString(FTell(),0x30);
    local int strLen = Strstr(stringStore,'\xFF');
    char string1[strLen]; 
    FSeek(header.stringOffsets[1]+0x100);
    stringStore = ReadString(FTell(),0x30);
    strLen = Strstr(stringStore,'\xFF');
    char string2[strLen]; 
    FSeek(header.stringOffsets[2]+0x100);
    string string3;
    //--------------------------------------//
} FAT_BOOTSECTOR <read=ReadFAT_BOOTSECTOR, optimize=false>;
//---------------------------------------//

//---------------------------------------------------------------------------------
//--- FAT Boot sector display from Drive.bt (Vernoux and SweetScape Software, 2022)
string ReadFAT_BOOTSECTOR( FAT_BOOTSECTOR &boot )
{
    return boot.VolumeLabel;
}
typedef enum <int> {
    boolean_false = 0,
    boolean_true = 1,
    boolean_true_negative_one = -1,
    boolean_just_use_true_and_false = 0xbaadf00d
} boolean;

boolean IsExactlyOneBitSet( UQUAD value ) {  return 0 == (value & (value-1));}


DWORD ReadFAT_BOOTSECTOR_CountOfDataClusters( FAT_BOOTSECTOR &boot )
{
    local DWORD rootDirectoryByteCount <hidden=true>;
    local DWORD rootDirectorySectors <hidden=true>;
    local DWORD sectorsPerFat <hidden=true>;
    local DWORD totalSectors <hidden=true>;
    local DWORD dataSectors <hidden=true>;
    local DWORD countOfClusters <hidden=true>;

    if (boot.BytesPerSector == 0) return 0;
    if (!IsExactlyOneBitSet(boot.BytesPerSector)) return false;

    if (boot.BytesPerSector != 512) { // TODO: Fix 4k native sectors to show correct file data
        Printf("WARNING: Potentially valid FAT file system at 0x%x.\r\n", startof(boot));
        Printf("         Shows non-512 bytes per sector (0x%x)\r\n", boot.BytesPerSector);
        Printf("         Treating as unsupported drive due to known bugs\r\n");
        return 0; 
    }

    // First, the number of sectors in the special root directory area
    rootDirectoryByteCount = boot.MaxRootDirEntries * 32;
    rootDirectorySectors = rootDirectoryByteCount / boot.BytesPerSector;
    if (rootDirectoryByteCount % boot.BytesPerSector != 0) {
        rootDirectorySectors++;
    }

    // Next, the number of sectors in the data region
    sectorsPerFat    = boot.SectorsPerFat;
    totalSectors     = boot.NumberOfSectors;
    dataSectors      = totalSectors;
    dataSectors     -= boot.ReservedSectors;
    dataSectors     -= boot.NumberOfFatTables * sectorsPerFat;
    dataSectors     -= rootDirectorySectors;
    countOfClusters  = dataSectors / boot.SectorsPerCluster; // note that this rounds down
    return countOfClusters;
}
//--------------------------------------------------------------------------//


//--- Compute bitlocker header
FAT_BOOTSECTOR header;



//---------------------------------------
//---TPM20.h from:
//---https://github.com/tianocore/edk2/tree/master/MdePkg/Include/IndustryStandard (Intel, 2015)
//---With modifications for the 010 editor syntax and operation, including modifying TPM12.h (Intel, 2008)
//---TPM12.h modifications: remove all pointers ('*'s); remove '#pragma pack's; and add UINT8 definition.
//---See TPM20.h for modifications denoted by "//---"
#include <TPM20.h>
//---------------------------------------//



//---------------------------------------
//--- Initial BDE metadata header from https://github.com/libyal/libbde/blob/main/libbde/bde_metadata.h#L90-L152 (Metz, 2022)
//--- Retyped for the 010 editor template
struct bde_metadata_block_header_v2
{
	/* The signature
	 * Consists of 8 bytes
	 * Contains: -FVE-FS-
	 */
	char signature[ 8 ];

	/* The size
	 * Consists of 2 bytes
	 */
	short size;

	/* The version
	 * Consists of 2 bytes
	 */
	short version;

	/* Unknown
	 * Consists of 2 bytes
	 */
	short unknown1 <format=hex>;

	/* Unknown
	 * Consists of 2 bytes
	 */
	short unknown2 <format=hex>;

	/* The encrypted volume size
	 * Consists of 8 bytes
	 */
	int64 encrypted_volume_size;

	/* Unknown
	 * Consists of 4 bytes
	 */
	int unknown3 <format=hex>;

	/* The number of volume header sectors
	 * Consists of 4 bytes
	 */
	int number_of_volume_header_sectors;

	/* The first FVE metadata offset
	 * Consists of 8 bytes
	 */
	int64 first_metadata_offset <format=hex>;

	/* The second FVE metadata offset
	 * Consists of 8 bytes
	 */
	int64 second_metadata_offset <format=hex>;

	/* The third FVE metadata offset
	 * Consists of 8 bytes
	 */
	int64 third_metadata_offset <format=hex>;

	/* The volume header offset offset
	 * Consists of 8 bytes
	 */
	int64 volume_header_offset <format=hex>;
};


/*---
//--- Structure for datum types global (inferred from fveapi.dll source code and data layout)---//

struct DatumTypeStruct{
    short   DatumHeaderSize;
    bool    isNested;
}

#define MAX_DATUM_TYPES 22
typedef DatumTypeStruct* DatumTypes[MAX_DATUM_TYPES];
//--- An array of the values in fveapi.dll's Global
local DatumTypeStruct DatumTypes[MAX_DATUM_TYPES] = {
//---FveDatumErasedTypeProp, 0,              {08h,false},
//---FveDatumKeyTypeProp, 1                  {0Ch,0},
//---FveDatumUnicodeTypeProp, 2              {08h,0},
//---FveDatumStretchKeyTypeProp, 3           {1Ch,true},
//---FveDatumUseKeyTypeProp, 4               {0Ch,true},
//---FveDatumAesCcmEncTypeProp, 5            {24h,0},
//---FveDatumTpmEncBlobTypeProp, 6           {0Ch,0},
//---FveDatumValidationInfoTypeProp, 7       {08h,0},
//---FveDatumVmkInfoTypeProp, 8              {24h,true},    
//---FveDatumExternalInfoTypeProp, 9         {20h,true},     
//---FveDatumUpdateTypeProp, 10              {2Ch,true},    
//---FveDatumErrorTypeProp, 11               {34h,0},   

//---According to https://github.com/Aorimn/dislocker/blob/master/include/dislocker/metadata/datums.h#L269
//---The below datums were added with Windows 7  (Coltel and Consultants, 2022)
//---FveDatumAsymEncTypeProp, 12             {08h,0},
//---FveDatumExportedKeyTypeProp, 13         {08h,0},
//---FveDatumPublicKeyInfoTypeProp, 14,      {08h,0},
//---FveDatumVirtualizationInfoTypeProp, 15, {18h,0},
//---FveDatumSimpleTypeProp1, 16,            {0Ch,0},
//---FveDatumSimpleTypeProp2, 17,            {0Ch,0},
//---FveDatumConcatHashKeyTypeProp, 18,      {1Ch,0},
//---FveDatumSimpleTypeProp3, 19,            {0Ch,0},
//---FveDatumSimpleLargeTypeProp, 20,        {10h,0},
//---FveDatumBackupInfoTypeProp, 21,         {1Ch,0}
};
---*/

//---------------------------------------
//--- These structures are taken from an fveapi.dll Global at virtual offset: 0x1800bae90 with structure DatumTypes (see above), 
//--- The datum names are taken from fveapi.pdb with FveDatumSimpleTypePropX enumerated.
//--- The same DatumTypes structure is found in bootmgfw.efi Global at virtual offset: 0x10013490.
//--- This Global is referenced in FveDatumHeaderSafe in both executables among other references.
enum<WORD> DATUM_TYPES{
    FveDatumErasedTypeProp = 0,
    FveDatumKeyTypeProp,
    FveDatumUnicodeTypeProp,
    FveDatumStretchKeyTypeProp,
    FveDatumUseKeyTypeProp,
    FveDatumAesCcmEncTypeProp,
    FveDatumTpmEncBlobTypeProp,
    FveDatumValidationInfoTypeProp,
    FveDatumVmkInfoTypeProp,  
    FveDatumExternalInfoTypeProp,    
    FveDatumUpdateTypeProp, 
    FveDatumErrorTypeProp,   
    FveDatumAsymEncTypeProp,
    FveDatumExportedKeyTypeProp,
    FveDatumPublicKeyInfoTypeProp,
    FveDatumVirtualizationInfoTypeProp,
    FveDatumSimpleTypeProp1,
    FveDatumSimpleTypeProp2,
    FveDatumConcatHashKeyTypeProp,
    FveDatumSimpleTypeProp3,
    FveDatumSimpleLargeTypeProp,
    FveDatumBackupInfoTypeProp
};
//-------------------------------------------//


//-------------------------------------------------
//--- Enum of Datum 'roles'
//--- Created from:
//--- https://github.com/mbroz/cryptsetup/blob/main/lib/bitlk/bitlk.h#L57-L65 (Trefny, Broz and Hat, 2024)
//--- https://github.com/thewhiteninja/ntfstool/blob/master/Sources/Bitlocker/fve.h#L28 (thewhiteninja, 2021)
//--- https://github.com/libyal/libbde/blob/main/libbde/libbde_definitions.h.in#L88-L100 (Metz, 2022)
//--- https://github.com/Aorimn/dislocker/blob/master/include/dislocker/metadata/datums.h#L78-L93 (Coltel and Consultants, 2022;)

//--- TPM + PIN specific roles are validated independently (denoted with //*//)
enum<WORD> ROLE_TYPES{
    PROPERTY        = 0x0, //*//

    VMK             = 0x2, //*//
    FVEK            = 0x3, //*//
    VALIDATION      = 0x4,

    EXT_KEY         = 0x6,
    DESCRIPTION     = 0x7, //*//

    //---AKA AUTO_UNLOCK in thewhiteninja (2021)---//
    FVEK_BAK        = 0xb,

    VOL_HEAD        = 0xf, //*//

    //---Exclusively listed in Trefny, Broz and Hat (2024)---//
    VOL_GUID        = 0x19
};
//-----------------------------------------------//


enum<ushort> cipher_types
{
    //---------------------------------------
    //---These Encryption types from:
    //---FveVmkInfoConvertCreateParams, FveVmkInfoCreate and FveDatumPerformConcatHash
    //---in fveapi.dll (function names from fveapi.pdb)---//
	STRETCH_RECOVERY_PASSWORD   = 0x1000,
    STRETCH_KEY_1   = 0x1001,

	AES_CCM_256_0 = 0x2000,
	AES_CCM_256_1 = 0x2001,
	AES_CCM_256_EXTERN_KEY    = 0x2002,
	AES_CCM_256_VMK           = 0x2003,
	AES_CCM_256_PIN = 0x2004,
    
    //---From FveDatumPerformConcatHash
	AES_CCM_256_CONCAT_HASH      = 0x2005,
	AES_CCM_256_PUBLIC_KEY      = 0x2006,
	AES_CCM_256_PASSPHRASE     = 0x2007,
    AES_CCM_256_REOCVERY_PASSWORD = 0x2008,
    //---------------------------------------//
    
	AES_128_DIFFUSER    = 0x8000,
	AES_256_DIFFUSER    = 0x8001,
	AES_128_NO_DIFFUSER = 0x8002,
	AES_256_NO_DIFFUSER = 0x8003,
	AES_XTS_128         = 0x8004,
	AES_XTS_256         = 0x8005,

	DIS_CIPHER_LOWEST_SUPPORTED  = 0x8000,
	DIS_CIPHER_HIGHEST_SUPPORTED = 0x8005,
};

// Structures we want.
// BitLocker metadata header. (BitLocker Drive Encryption (BDE) format.asciidoc 5.2)
struct _FVE_DATASET
{
  unsigned int DataSetSize;
  unsigned int DataSetVersion;
  unsigned int DataSetStart;
  unsigned int DataSetEnd;
  GUID FveIdentification;
  unsigned int NonceCounter;
  cipher_types FvekType <format=hex>;
  cipher_types FvekPrefType <format=hex>;
  FILETIME DateTime;
};

// BitLocker metadata entry header. (BitLocker Drive Encryption (BDE) format.asciidoc 5.3)
struct  _FVE_DATUM
{
  WORD StructureSize;
  ROLE_TYPES Role;
  DATUM_TYPES Type;
  WORD Flags;
};

typedef struct _extended_info {
	uint16 unknown1;
	uint16 size;
	uint32 unknown2;
	uint64 flags;
	uint64 convertlog_addr;
	uint32 convertlog_size;
	uint32 sector_size1;
	uint32 sector_size2;
} extended_info_t;

struct PROTECTOR_TYPES{
byte    RESERVED;    
byte    TPM : 1;
byte    EXTERNAL_KEY : 1;
byte    PIN : 1  ;
byte    RECOVERY_PASSWORD   : 1;
byte    UKNOWN  :   1;
byte    PASSPHRASE  :   1;
};
/*
typedef struct _datum_aes_ccm
{
	datum_header_safe_t header;
	uint8_t nonce[12];
	uint8_t mac[16];
} datum_aes_ccm_t;
*/


string READ_PROTECTOR_TYPE(PROTECTOR_TYPES &flag){
    local string RetStr = "";
    if (flag.TPM){
        RetStr += "TPM";
    }
    if (flag.PIN){
        RetStr +=" + PIN";
        }
    if (flag.EXTERNAL_KEY){
        if (RetStr == ""){
            RetStr += "USB";
            }
        else{
            RetStr +=" + USB";
            }
        }
    if (flag.RECOVERY_PASSWORD){
        RetStr+="Recovery Password";
    }
    if (flag.PASSPHRASE){
        RetStr+="PassPhrase";
    }
    return RetStr;
};

//---------------------------------------
//---Key Flags suggested by
//---FveDatumVmkQueryIsEnhancedPinOrEnhancedCrypto and FveDatumFromPin
//---Supported by testing
enum<WORD> KEY_FLAGS{
    EnhancedPin  = 0x4,
    NonEnhancedPin = 0x10  
};
//---------------------------------------//

//---Forward declaration
struct PCR_BITMAP;
string readPCR_BITMAP(PCR_BITMAP &pcrs){
    local string out = "PCRs: ";
    if (pcrs.PCR_0){
        out+="0, ";
        };
    if (pcrs.PCR_1){
        out+="1, ";
    }; 
    if (pcrs.PCR_2){
        out+="2, ";
    }; 
    if (pcrs.PCR_3){
        out+="3, ";
    };
    if (pcrs.PCR_4){
        out+="4, ";
    };
    if (pcrs.PCR_5){
        out+="5, ";
    }; 
    if (pcrs.PCR_6){
        out+="6, ";
    }; 
    if (pcrs.PCR_7){
        out+="7, ";
    }; 
    if (pcrs.PCR_8){
        out+="8, ";
    }; 
    if (pcrs.PCR_9){
        out+="9, ";
    }; 
    if (pcrs.PCR_10){
        out+="10, ";
    }; 
    if (pcrs.PCR_11){
        out+="11, ";
    }; 
    if (pcrs.PCR_12){
        out+="12, ";
    }; 
    if (pcrs.PCR_13){
        out+="13, ";
    }; 
    if (pcrs.PCR_14){
        out+="14, ";
    }; 
    if (pcrs.PCR_15){
        out+="15, ";
    }; 
    if (pcrs.PCR_16){
        out+="16, ";
    }; 
    if (pcrs.PCR_17){
        out+="17, ";
    };
    if (pcrs.PCR_18){
        out+="18, ";
    }; 
    if (pcrs.PCR_19){
        out+="19, ";
    }; 
    if (pcrs.PCR_20){
        out+="20, ";
    }; 
    if (pcrs.PCR_21){
        out+="21, ";
    }; 
    if (pcrs.PCR_22){
        out+="22, ";
    }; 
    if (pcrs.PCR_23){
        out+="23, ";
    }; 
    out = StrDel(out, Strlen(out)-2, 2);
    return out;
    };

    
typedef struct{
    short PCR_0 : 1;
    short PCR_1 : 1;
    short PCR_2 : 1;
    short PCR_3 : 1;
    short PCR_4 : 1;
    short PCR_5 : 1;
    short PCR_6 : 1;
    short PCR_7 : 1;
    short PCR_8 : 1;
    short PCR_9 : 1;
    short PCR_10 : 1;
    short PCR_11 : 1;
    short PCR_12 : 1;
    short PCR_13 : 1;
    short PCR_14 : 1;
    short PCR_15 : 1;
    byte PCR_16 : 1;
    byte PCR_17 : 1;
    byte PCR_18 : 1;
    byte PCR_19 : 1;
    byte PCR_20 : 1;
    byte PCR_21 : 1;
    byte PCR_22 : 1;
    byte PCR_23 : 1;
    }  PCR_BITMAP  <read = readPCR_BITMAP>;
    
struct SENSITIVE_DUMMY (uint outPrivate_size) {
    //--- Dummy TPM2B_SENSITIVE structure to work out size of encrypted data ---//
    UINT16            sensitive_size;
    
    // TPMT_SENSITIVE    sensitiveArea:

        //---------------------------------------
        //---sensitiveType is the same as outPublic.publicArea.Type 
        //---TPM 2.0 Part 2 Page 158 (TCG, 2024b:158)
        //---------------------------------------//
        TPMI_ALG_PUBLIC             sensitiveType;
        
        // TPM2B_AUTH        authValue;
            UINT16    authValue_size;
            BYTE      authValue_buffer[32]; /*Guessed authValue size*/
        
        // TPM2B_DIGEST      seedValue;
            UINT16    seedValue_size;
            //---------------------------------------
            //---Size taken from outPublic.publicArea.nameAlg
            //---TPM 2.0 Part 1 Page 186 (TCG, 2024a:186)
            //---------------------------------------//
            BYTE      seedValue_buffer[32];

        // TPMU_SENSITIVE_COMPOSITE sensitive(sensitiveType):
        // TPM2B_SENSITIVE_DATA   bits:
            UINT16    bits_size;
            local long encSize = outPrivate_size
                                        -sizeof(integrityOuter)-sizeof(integrityInner)
                                            -sizeof(sensitive_size)-sizeof(sensitiveType)
                                                -sizeof(authValue_size)-sizeof(authValue_buffer)
                                                    -sizeof(seedValue_size)-sizeof(seedValue_buffer)
                                                        -sizeof(bits_size);
            //---Expected TPM Only protected VMK---//
            if (encSize == 44){
                LittleEndian();
                //
                //_FVE_DATUM h;      //---Example Values
                    WORD StructureSize; // 0x002c //---Fixed---//
                    ROLE_TYPES Role;    // 0x0000
                    DATUM_TYPES Type;   // 0x0010 //---Most likely fixed---//
                    WORD Flags;         // 0x0000
                
                cipher_types KeyType; //---AES_CCM_256_VMK---//
                KEY_FLAGS KeyFlags;   //---0x0000---//
                BYTE VMK[32];
                BigEndian();
            //---Expected TPM + PIN protected Intemediate Key---//
            }else if (encSize == 80){
                LittleEndian();
                //_FVE_DATUM h;      //---Example Values
                    WORD StructureSize; // 0x002c //---Fixed---//
                    ROLE_TYPES Role;    // 0x0000
                    DATUM_TYPES Type;   // 0x0010 //---Most likely fixed---//
                    WORD Flags;         // 0x0000
                FILETIME nonceTime;
                int nonceCounter;
                byte HMAC[16] <format=hex>;
                //AES-CCM Encrypted with SHA256{Stretched PIN + "BitlockerAuthData"}
                    //_FVE_DATUM h;
                        WORD StructureSize; // 0x002c //---Fixed---//
                        ROLE_TYPES Role;
                        DATUM_TYPES Type;   // 0x0010 //---Most likely fixed---//
                        WORD Flags;
                    
                    cipher_types KeyType; 
                    KEY_FLAGS KeyFlags;
                    BYTE IK[32]; //Stored intermediate key not VMK
                BigEndian();
            }else{
            BYTE      EncryptedDatums[encSize];
            };
};
struct TPM2B_PRIVATE_W_DUMMY{
          
      // TPM2B_PRIVATE outPrivate:
      UINT16    outPrivate_size;
      
      // _PRIVATE buffer[size]:
        TPM2B_DIGEST      integrityOuter;
        TPM2B_DIGEST      integrityInner;
        // byte    encryptedSensitive[size-integrityOuter.size-integrityInner.size-4]:
        SENSITIVE_DUMMY    encryptedSensitive(outPrivate_size);
    };
struct _FVE_DATUM_TEMP;
struct _FVE_DATUM_TEMP
{
  _FVE_DATUM h;  
  
  if (h.Type == FveDatumErasedTypeProp){
    byte DatumData[h.StructureSize-8];
    }
  else if (h.Type == FveDatumKeyTypeProp){
    cipher_types KeyType;
    KEY_FLAGS KeyFlags; // bit 0 internally used as "derived from TPM, ensure secureboot policy flag bit2 is set", but not ever set elsewhere...
    byte KeyData[h.StructureSize-12];
    }
  else if (h.Type == FveDatumUnicodeTypeProp){
    wchar_t UnicodeData[(h.StructureSize-8)/2];
  }
  else if (h.Type == FveDatumStretchKeyTypeProp){
     /* The encryption method
	 * Consists of 4 bytes
	 */
	cipher_types encryption_method <format = hex>;
    
    /* Likely represents keyFlags suggested by
    *  FveDatumVmkQueryIsEnhancedPinOrEnhancedCrypto and FveDatumFromPin
    */
    KEY_FLAGS  keyFlags; 
    
	/* The salt
	 * Consists of 16 bytes
	 */
	byte salt1[16] <format = hex>;
    
    local int Datums = GetNoOfDatums(h.StructureSize-28);
    _FVE_DATUM_TEMP StretchDatums[Datums] <read = READ_DATUM_TYPE,optimize=false>;
  }
  else if (h.Type == FveDatumUseKeyTypeProp){
      byte UseKeyData[4];
      byte DatumData[h.StructureSize-12];
  }
  else if (h.Type == FveDatumAesCcmEncTypeProp){
      FILETIME nonceTime;
      int nonceCounter;
      byte HMAC[16] <format=hex>;
      byte AesCCMData[h.StructureSize-36];  
  }
  else if (h.Type == FveDatumTpmEncBlobTypeProp){
      PCR_BITMAP PCRBitmap;
      byte zero; /*Potentially always 0x00*/
      BigEndian();
      
      // Can be uncommented but latter structure is used to determine encrypted data size
      // TPM2B_PRIVATE outPrivate; 
      TPM2B_PRIVATE_W_DUMMY outPrivateWDummy;

      TPM2B_PUBLIC outPublic;
      TPM2B_DIGEST PCRDigest;
      LittleEndian();
      byte sizeOfBitmap <format = hex>;
      PCR_BITMAP PCRBitmap_End;
  }
  else if (h.Type == FveDatumVmkInfoTypeProp){
        GUID Identifier;
        FILETIME DateTime;
        WORD VmkHints;
        PROTECTOR_TYPES ProtectionType<read=READ_PROTECTOR_TYPE>;
        local int Datums = GetNoOfDatums(h.StructureSize-36);
        _FVE_DATUM_TEMP VMKDatums[Datums] <read = READ_DATUM_TYPE,optimize=false>;
  }
  else if (h.Type == FveDatumVirtualizationInfoTypeProp){
        UINT64 NTFSBootSectorsAddr;
	    UINT64 BackupBytes;
        extended_info_t ExtendedInfo; 
        byte ExtExtInfo[h.StructureSize-sizeof(_FVE_DATUM)-sizeof(UINT64)-sizeof(UINT64)-sizeof(extended_info_t)];
  }
  else{
      byte KeyData[h.StructureSize-8];
  }
    
};
string READ_DATUM_TYPE(_FVE_DATUM_TEMP &datum){
    local string RetStr = "";
    RetStr += EnumToString(datum.h.Role);
    RetStr += ": ";
    RetStr += EnumToString(datum.h.Type);
    return RetStr;
};
int GetNoOfDatums(uint size){
    local uint currOffset = FTell();
    local uint sizeLeft = size;
    local int count = 0;
    local int sizeStore = 0;
    while (sizeLeft>0){
        sizeStore = ReadUShort(currOffset);
        currOffset += sizeStore;
        sizeLeft-=sizeStore;
        count+=1;
    }
    return count;
}

struct FveHeaderBlock(int currOffset){
    bde_metadata_block_header_v2 FVEBlockHeader;
    _FVE_DATASET FVEDataset;
    local int Datums = GetNoOfDatums(FVEDataset.DataSetSize - FVEDataset.DataSetStart);
    _FVE_DATUM_TEMP DATUMS[Datums] <read = READ_DATUM_TYPE, optimize=false>;
};

FSeek(header.FVEMetatdata1);
FveHeaderBlock FVEHeaderBlock1(header.FVEMetatdata1);

FSeek(header.FVEMetatdata2);
Printf("%x",header.FVEMetatdata2);
FveHeaderBlock FVEHeaderBlock2(header.FVEMetatdata2);

FSeek(header.FVEMetatdata3);
Printf("%x",header.FVEMetatdata3);
FveHeaderBlock FVEHeaderBlock3(header.FVEMetatdata3);

