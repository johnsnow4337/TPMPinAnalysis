//------------------------------------------------
//--- 010 Editor v14.0.1 Binary Template
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------
//------------------------------------------------
//--- 010 Editor v14.0.1 Binary Template
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------
#include <tpm12.h>
#include <tpm20.h>
typedef struct
{
  unsigned char _0;
  unsigned char _1;
  unsigned char _2;
} int24_t<read=read_int24_t, optimize=false, size=3>;
int value_int24_t (int24_t& ref)
{
  int _0 = ref._0;
  int _1 = ref._1;
  int _2 = ref._2;
  int combined =  _0 | (_1 << 8) | (_2 << 16);
  if (combined & 0x800000)
  {
    combined = combined;
  }
  return combined;
}
string read_int24_t (int24_t& ref)
{
  string a;
  SPrintf (a, "%Xh", value_int24_t (ref));
  return a;
}
typedef enum <uint32> {
    FILE_SYSTEM_TYPE_NONE    = 0x0000,
    FILE_SYSTEM_TYPE_IFS     = 0x0010,
    FILE_SYSTEM_TYPE_NTFS    = 0x0020,
    FILE_SYSTEM_TYPE_HPFS    = 0x0040,
    FILE_SYSTEM_TYPE_FAT12   = 0x0100,
    FILE_SYSTEM_TYPE_FAT16   = 0x0200,
    FILE_SYSTEM_TYPE_FAT32   = 0x0400,
    FILE_SYSTEM_TYPE_EXFAT   = 0x0800,
} FILE_SYSTEM_TYPE <read=ReadFILE_SYSTEM_TYPE>;
// Media descriptor
typedef enum <uchar>
{
    FLOPPY                        = 0xf0,
    HARD_DRIVE                    = 0xf8,
    FLOPPY_320K_1                 = 0xfa,
    FLOPPY_640K                   = 0xfb,
    FLOPPY_180K                   = 0xfc,
    FLOPPY_360K                   = 0xfd,
    FLOPPY_160K                   = 0xfe,
    FLOPPY_320K_2                 = 0xff,
} MEDIA <format=hex>;

typedef struct  {
    local INT64 tmp <hidden=true>;
    local DWORD ClusterSize;
    local DWORD NumberOfSectors;
    local DWORD SectorsPerFat;
    local DWORD CountOfDataClusters;
    local DWORD MaximumValidClusterNumber;

    local FILE_SYSTEM_TYPE FsType = FILE_SYSTEM_TYPE_NONE;

    BYTE    jmp[3]                <format=hex>;
    CHAR    OemName[8];
    USHORT  BytesPerSector        <format=hex>; // legal == { 512, 1024, 2048, 4096 }
    UBYTE   SectorsPerCluster     <format=hex>; // legal == { 1, 2, 4, 8, 16, 32, 64, 128 }
    USHORT  ReservedSectors       <format=hex>; // must not be zero; legal for FAT12/16 == { 1 }, typically 32 for FAT32
    UBYTE   NumberOfFatTables     <format=hex>; // must not be zero; warn if this is not set to the value 1 or 2
    USHORT  MaxRootDirEntries     <format=hex>; // legal for FAT12/16 == N * (BytesPerSector / 32), N is non-zero; must be {0} for FAT32
    USHORT  NumberOfSectors16     <format=hex>; // must be {0} for FAT32; if {0}, then NumberOfSectors32 must be non-zero
    MEDIA   MediaDescriptor       <format=hex>; // legacy
    USHORT  SectorsPerFat16       <format=hex>; // must be {0} for FAT32; must be non-zero for FAT12/16
    USHORT  SectorsPerTrack       <format=hex>; // legacy
    USHORT  HeadsPerCylinder      <format=hex>; // legacy
    ULONG   NumHiddenSectors      <format=hex>; // legacy
    ULONG   NumberOfSectors32     <format=hex>; // must be non-zero for FAT32; must be >= 0x10000 if NumberOfSectors16 is zero

    // PREVENTS ARRAY OPTIMIZATION because depends on instance value
    if (0 == this.SectorsPerFat16) { // FAT32 starting at sector offset 36 
        DWORD SectorsPerFat32    <format=hex>;
        WORD  ActiveFatIndex : 4 <format=hex>; // zero-based index of the active FAT
        WORD  FlagsReserved1 : 3 <format=hex>; 
        WORD  TransactionFat : 1 <format=hex>; // 1 means only one FAT active, as indicated by ActiveFatIndex; 0 means both FATs are mirrored
        WORD  FlagsReserved2 : 8 <format=hex>;
        WORD  Version            <format=hex>; // must be 0
        DWORD RootCluster        <format=hex>; // cluster number (FAT index) for root.  usually 2.  preferably first non-bad sector.
        WORD  InfoSector         <format=hex>; // usually 1.
        WORD  BootBackupStart    <format=hex>; // usually 6.  No other value than 6 is recommended
        BYTE  Reserved[12]       <format=hex>; // set to zero by formatting utility, no indicaton of other uses but shall be ignored/preserved
    }

    BYTE   DriveNumber        <format=hex>;
    BYTE   Unused             <format=hex>;
    BYTE   ExtBootSignature   <format=hex>;
    DWORD  SerialNumber       <format=hex>; // only valid if ExtBootSignature == 0x29
    CHAR   VolumeLabel[11]    <format=hex>; // only valid if ExtBootSignature == 0x29
    CHAR   FileSystemLabel[8] <format=hex>; // only valid if ExtBootSignature == 0x29

    // PREVENTS ARRAY OPTIMIZATION
    // Added Bitlocker Specific Metadata
    tmp = 510 - (FTell() - startof(jmp)) - 110; // 420 for FAT32, 448 for FAT16/12
    UBYTE  BootCode1[70]       <format=hex>;
    GUID   BitlockerID;
    int64  FVEMetatdata1      <format=hex>;
    int64  FVEMetatdata2      <format=hex>;
    int64  FVEMetatdata3      <format=hex>;
    UBYTE  BootCode[tmp]      <format=hex>;
    WORD   EndOfSectorMarker  <format=hex>;

    // Helpers to make FAT12/16/32 more common -- all of which prevent array optimization
    ClusterSize      = this.BytesPerSector * this.SectorsPerCluster;
    NumberOfSectors  = (this.NumberOfSectors16 != 0) ? this.NumberOfSectors16 : this.NumberOfSectors32;
    SectorsPerFat    = (this.SectorsPerFat16   != 0) ? this.SectorsPerFat16   : this.SectorsPerFat32;
    CountOfDataClusters = ReadFAT_BOOTSECTOR_CountOfDataClusters(this);
    MaximumValidClusterNumber = CountOfDataClusters + 1; // +2, but zero-based indexing, so largest valid value is Count+1

    if (CountOfDataClusters == 0) {
        //Printf("WARNING: Count of data clusters computed as zero, so not valid FAT filesystem\r\n");
        FsType = FILE_SYSTEM_TYPE_NONE; // oops
    } else if (CountOfDataClusters < 4085) {
        FsType = FILE_SYSTEM_TYPE_FAT12;
    } else if (CountOfDataClusters < 65525) {
        FsType = FILE_SYSTEM_TYPE_FAT16;
    } else if (CountOfDataClusters < 0x0FFFFFF0 - 2) {
        FsType = FILE_SYSTEM_TYPE_FAT32;
    } else {
        FsType = FILE_SYSTEM_TYPE_NONE; // oops
    }
} FAT_BOOTSECTOR <read=ReadFAT_BOOTSECTOR, optimize=false>;
string ReadFAT_BOOTSECTOR( FAT_BOOTSECTOR &boot )
{
    return boot.VolumeLabel;
}
typedef enum <int> {
    boolean_false = 0,
    boolean_true = 1,
    boolean_true_negative_one = -1,
    boolean_just_use_true_and_false = 0xbaadf00d
} boolean;

boolean IsExactlyOneBitSet( UQUAD value ) {  return 0 == (value & (value-1));}


DWORD ReadFAT_BOOTSECTOR_CountOfDataClusters( FAT_BOOTSECTOR &boot )
{
    local DWORD rootDirectoryByteCount <hidden=true>;
    local DWORD rootDirectorySectors <hidden=true>;
    local DWORD sectorsPerFat <hidden=true>;
    local DWORD totalSectors <hidden=true>;
    local DWORD dataSectors <hidden=true>;
    local DWORD countOfClusters <hidden=true>;

    if (boot.BytesPerSector == 0) return 0;
    if (!IsExactlyOneBitSet(boot.BytesPerSector)) return false;

    if (boot.BytesPerSector != 512) { // TODO: Fix 4k native sectors to show correct file data
        Printf("WARNING: Potentially valid FAT file system at 0x%x.\r\n", startof(boot));
        Printf("         Shows non-512 bytes per sector (0x%x)\r\n", boot.BytesPerSector);
        Printf("         Treating as unsupported drive due to known bugs\r\n");
        return 0; 
    }

    // First, the number of sectors in the special root directory area
    rootDirectoryByteCount = boot.MaxRootDirEntries * 32;
    rootDirectorySectors = rootDirectoryByteCount / boot.BytesPerSector;
    if (rootDirectoryByteCount % boot.BytesPerSector != 0) {
        rootDirectorySectors++;
    }

    // Next, the number of sectors in the data region
    sectorsPerFat    = boot.SectorsPerFat;
    totalSectors     = boot.NumberOfSectors;
    dataSectors      = totalSectors;
    dataSectors     -= boot.ReservedSectors;
    dataSectors     -= boot.NumberOfFatTables * sectorsPerFat;
    dataSectors     -= rootDirectorySectors;
    countOfClusters  = dataSectors / boot.SectorsPerCluster; // note that this rounds down
    return countOfClusters;
}

FAT_BOOTSECTOR header;

struct bde_metadata_block_header_v1
{
	/* The signature
	 * Consists of 8 bytes
	 * Contains: -FVE-FS-
	 */
	char signature[ 8 ];

	/* The size
	 * Consists of 2 bytes
	 */
	short size;

	/* The version
	 * Consists of 2 bytes
	 */
	short version;

	/* Unknown
	 * Consists of 2 bytes
	 */
	short unknown1 <format=hex>;

	/* Unknown
	 * Consists of 2 bytes
	 */
	short unknown2 <format=hex>;

	/* Unknown
	 * Consists of 16 bytes
	 */
	byte unknown3[ 16 ] <format=hex>;

	/* The first FVE metadata offset
	 * Consists of 8 bytes
	 */
	int64 first_metadata_offset <format=hex>;

	/* The second FVE metadata offset
	 * Consists of 8 bytes
	 */
	int64 second_metadata_offset <format=hex>;

	/* The third FVE metadata offset
	 * Consists of 8 bytes
	 */
	int64 third_metadata_offset <format=hex>;

	/* The MFT mirror cluster block number
	 * Consists of 8 bytes
	 */
	int64 mft_mirror_cluster_block <format=hex>;
};

struct bde_metadata_block_header_v2
{
	/* The signature
	 * Consists of 8 bytes
	 * Contains: -FVE-FS-
	 */
	char signature[ 8 ];

	/* The size
	 * Consists of 2 bytes
	 */
	short size;

	/* The version
	 * Consists of 2 bytes
	 */
	short version;

	/* Unknown
	 * Consists of 2 bytes
	 */
	short unknown1 <format=hex>;

	/* Unknown
	 * Consists of 2 bytes
	 */
	short unknown2 <format=hex>;

	/* The encrypted volume size
	 * Consists of 8 bytes
	 */
	int64 encrypted_volume_size;

	/* Unknown
	 * Consists of 4 bytes
	 */
	int unknown3 <format=hex>;

	/* The number of volume header sectors
	 * Consists of 4 bytes
	 */
	int number_of_volume_header_sectors;

	/* The first FVE metadata offset
	 * Consists of 8 bytes
	 */
	int64 first_metadata_offset <format=hex>;

	/* The second FVE metadata offset
	 * Consists of 8 bytes
	 */
	int64 second_metadata_offset <format=hex>;

	/* The third FVE metadata offset
	 * Consists of 8 bytes
	 */
	int64 third_metadata_offset <format=hex>;

	/* The volume header offset offset
	 * Consists of 8 bytes
	 */
	int64 volume_header_offset <format=hex>;
};

struct bde_metadata_header_v1
{
	/* The metadata size
	 * Consists of 4 bytes
	 */
	int metadata_size;

	/* The version
	 * Consists of 4 bytes
	 */
	int version;

	/* The metadata header size
	 * Consists of 4 bytes
	 */
	int metadata_header_size;

	/* The metadata size copy
	 * Consists of 4 bytes
	 */
	int metadata_size_copy;

	/* The volume identifier
	 * Consists of 16 bytes
	 */
	GUID volume_identifier;

	/* The next nonce counter
	 * Consists of 4 bytes
	 */
	int next_nonce_counter;

	/* The encryption method
	 * Consists of 2 bytes
	 */
	ushort encryption_method <format=hex>;

	/* The encryption method copy
	 * Consists of 2 bytes
	 */
	ushort encryption_method_copy <format=hex>;

	/* The creation date and time
	 * Consists of 8 bytes
	 * Contains a filetime
	 */
	FILETIME creation_time;
};


enum<ushort> ENC_TYPES{
NOT_ENC_OR_Ext = 0x0000,

STRETCH_0 = 0x1000,
STRETCH_1 = 0x1001,

AES_CCM_256_0 = 0x2000,
AES_CCM_256_1 = 0x2001,
AES_CCM_256_2 = 0x2002,
AES_CCM_256_3 = 0x2003,
AES_CCM_256_4 = 0x2004,
AES_CCM_256_5 = 0x2005,

AES_CBC_128_ED = 0x8000,
AES_CBC_256_ED = 0x8001,
AES_CBC_128 = 0x8003,
AES_CBC_256 = 0x8003,
AES_XTS_128 = 0x8004,
AES_XTS_256 = 0x8005
};

enum<WORD> DATUM_TYPES{
FveDatumErasedTypeProp = 0,
FveDatumKeyTypeProp,
FveDatumUnicodeTypeProp,
FveDatumStretchKeyTypeProp,
FveDatumUseKeyTypeProp,
FveDatumAesCcmEncTypeProp,
FveDatumTpmEncBlobTypeProp,
FveDatumValidationInfoTypeProp,
FveDatumVmkInfoTypeProp,  
FveDatumExternalInfoTypeProp,    
FveDatumUpdateTypeProp, 
FveDatumErrorTypeProp,   
FveDatumAsymEncTypeProp,
FveDatumExportedKeyTypeProp,
FveDatumPublicKeyInfoTypeProp,
FveDatumVirtualizationInfoTypeProp,
FveDatumSimpleTypeProp1,
FveDatumSimpleTypeProp2,
FveDatumConcatHashKeyTypeProp,
FveDatumSimpleTypeProp3,
FveDatumSimpleLargeTypeProp,
FveDatumBackupInfoTypeProp
};

enum<WORD> ROLE_TYPES{
PROP = 0x0000,
VMK = 0x2,
FVEK,
VALID,
EXT_KEY = 0x6,
DESCRIPTION,
FVEK_BAK = 0xb,
VOL_HEAD = 0xf    
};

local int DatumSizes[22] = {
/*FveDatumErasedTypeProp, 0,*/              08h
/*FveDatumKeyTypeProp, 1*/,                 0Ch
/*FveDatumUnicodeTypeProp, 2*/,             08h
/*FveDatumStretchKeyTypeProp, 3*/,          1Ch
/*FveDatumUseKeyTypeProp, 4*/,              0Ch
/*FveDatumAesCcmEncTypeProp, 5*/,           24h
/*FveDatumTpmEncBlobTypeProp, 6*/,          0Ch
/*FveDatumValidationInfoTypeProp, 7*/,      08h
/*FveDatumVmkInfoTypeProp, 8*/,             24h    
/*FveDatumExternalInfoTypeProp, 9*/,        20h     
/*FveDatumUpdateTypeProp, 10*/,             2Ch    
/*FveDatumErrorTypeProp, 11*/,              34h    
/*FveDatumAsymEncTypeProp, 12*/,            08h
/*FveDatumExportedKeyTypeProp, 13*/,        08h
/*FveDatumPublicKeyInfoTypeProp, 14*/,      08h
/*FveDatumVirtualizationInfoTypeProp, 15*/, 18h
/*FveDatumSimpleTypeProp1, 16*/,            0Ch
/*FveDatumSimpleTypeProp2, 17*/,            0Ch
/*FveDatumConcatHashKeyTypeProp, 18*/,      1Ch
/*FveDatumSimpleTypeProp3, 19*/,            0Ch
/*FveDatumSimpleLargeTypeProp, 20*/,        10h
/*FveDatumBackupInfoTypeProp, 21*/,         1Ch
};
// Structures we want.
// BitLocker metadata header. (BitLocker Drive Encryption (BDE) format.asciidoc 5.2)
struct _FVE_DATASET
{
  unsigned int DataSetSize;
  unsigned int DataSetVersion;
  unsigned int DataSetStart;
  unsigned int DataSetEnd;
  GUID FveIdentification;
  unsigned int NonceCounter;
  ENC_TYPES FvekType;
  ENC_TYPES FvekPrefType;
  FILETIME DateTime;
};

// BitLocker metadata entry header. (BitLocker Drive Encryption (BDE) format.asciidoc 5.3)
struct  _FVE_DATUM
{
  WORD StructureSize;
  ROLE_TYPES Role;
  DATUM_TYPES Type;
  WORD Flags;
};

// BitLocker key metadata blob. (BitLocker Drive Encryption (BDE) format.asciidoc 5.4)
struct _FVE_DATUM_KEY
{
  _FVE_DATUM h;
  WORD KeyType;
  WORD KeyFlags; // bit 0 internally used as "derived from TPM, ensure secureboot policy flag bit2 is set", but not ever set elsewhere...
  byte KeyData[h.StructureSize-12];
};

struct _FVE_DATUM_VMK_INFO
{
  _FVE_DATUM h;
  GUID Identifier;
  FILETIME DateTime;
  WORD VmkHints;
  WORD Priority;
};
// BitLocker key metadata blob. (BitLocker Drive Encryption (BDE) format.asciidoc 5.4)


struct bde_metadata_entry_v1
{
	/* The size
	 * Consists of 2 bytes
	 */
	int size[ 2 ];

	/* The type
	 * Consists of 2 bytes
	 */
	int type[ 2 ];

	/* The value type
	 * Consists of 2 bytes
	 */
	int value_type[ 2 ];

	/* The version
	 * Consists of 2 bytes
	 */
	int version[ 2 ];

};

struct bde_metadata_entry_key_header
{
	/* The encryption method
	 * Consists of 4 bytes
	 */
	ENC_TYPES encryption_method;
};

struct bde_metadata_entry_stretch_key_header
{
	/* The encryption method
	 * Consists of 4 bytes
	 */
	ENC_TYPES encryption_method[ 4 ];

	/* The salt
	 * Consists of 16 bytes
	 */
	int salt[ 16 ];
};

struct bde_metadata_entry_aes_ccm_encrypted_key_header
{
	/* The nonce date and time
	 * Consists of 8 bytes
	 * Contains a filetime
	 */
	FILETIME nonce_time;

	/* The nonce counter
	 * Consists of 4 bytes
	 */
	int nonce_counter;
};

struct bde_metadata_entry_volume_master_key_header
{
	/* The identfier
	 * Consists of 16 bytes
	 * Contains a GUID
	 */
	GUID identifier;

	/* The (last) modification date and time
	 * Consists of 8 bytes
	 * Contains a filetime
	 */
	FILETIME modification_time;

	/* Unknown
	 * Consists of 2 bytes
	 */
	short unknown1;

	/* The protection type
	 * Consists of 2 bytes
	 */
	int protection_type[ 2 ];
};

struct bde_metadata_entry_external_key_header
{
	/* The identfier
	 * Consists of 16 bytes
	 * Contains a GUID
	 */
	int identifier[ 16 ];

	/* The (last) modification date and time
	 * Consists of 8 bytes
	 * Contains a filetime
	 */
	int modification_time[ 8 ];
};

struct _FVE_DATUM_TEMP
{
  _FVE_DATUM h;  
  if (h.Type == 0){
    byte DatumData[h.StructureSize-8];
    }
  else if (h.Type == 1){
    WORD KeyType;
    WORD KeyFlags; // bit 0 internally used as "derived from TPM, ensure secureboot policy flag bit2 is set", but not ever set elsewhere...
    byte KeyData[h.StructureSize-12];
    }
  else if (h.Type == 2){
    wchar_t UnicodeData[(h.StructureSize-8)/2];
  }
  else if (h.Type == 3){
     /* The encryption method
	 * Consists of 4 bytes
	 */
	ENC_TYPES encryption_method;

	/* The salt
	 * Consists of 16 bytes
	 */
	byte salt[16];
  }
  else if (h.Type == 4){
      byte UseKeyData[4];
      byte DatumData[h.StructureSize-12];
  }
  else if (h.Type == 5){
      FILETIME nonceTime;
      int nonceCounter;
      byte AesCCMData[h.StructureSize-20];  
  }
  else if (h.Type == 6){
         
  }
  else{
      byte KeyData[h.StructureSize-8];
  }
    
};

int GetNoOfDatums(int Offset, int size){
    local int currOffset = Offset;
    local int sizeLeft = size;
    local int count = 0;
    local int sizeStore = 0;
    while (sizeLeft>0){
        sizeStore = ReadShort(currOffset);
        currOffset += sizeStore;
        sizeLeft-=sizeStore;
        count+=1;
    }
    return count;
}

struct FveHeaderBlock(int currOffset){
    bde_metadata_block_header_v2 FVEBlockHeader;
    _FVE_DATASET FVEDataset;
    local int Datums = GetNoOfDatums(currOffset+0x70, FVEDataset.DataSetSize - FVEDataset.DataSetStart);
    _FVE_DATUM_TEMP DATUMS[Datums] <optimize=false>;
};

FSeek(header.FVEMetatdata1);
FveHeaderBlock FVEHeaderBlock1(header.FVEMetatdata1);

FSeek(header.FVEMetatdata2);
FveHeaderBlock FVEHeaderBlock2(header.FVEMetatdata2);

FSeek(header.FVEMetatdata3);
FveHeaderBlock FVEHeaderBlock3(header.FVEMetatdata3);

